<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <!-- add title -->
    <title>Food Nutrition Indices: Data Visualization</title>
    
    <!-- import required libraries here -->
    <script type="text/javascript" src="../lib/d3.v5.min.js"></script>
    <script type="text/javascript" src="../lib/d3-dsv.min.js"></script>
    <script type="text/javascript" src="../lib/topojson.v2.min.js"></script>
    <script type="text/javascript" src="../lib/d3-tip.min.js"></script>
    <script type="text/javascript" src="../lib/d3-legend.min.js"></script>
    <script type="text/javascript" src="../lib/d3-geo-projection.v2.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Page layout */
        body { 
            margin: 0; 
            padding: 28px; 
            background: linear-gradient(180deg, #f7fbff 0%, #eef6fb 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
            color: #0f1724;
        }
        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 10px 16px 40px 16px;
        }
        h2 {
            text-align: center;
            margin: 6px 0 20px;
            font-weight: 600;
            color: #0b3d91;
            letter-spacing: -0.2px;
        }

        #choropleth {
            display: block;
            margin: 0 auto 12px auto;
            background: linear-gradient(180deg, #ffffff 0%, #fbfdff 100%);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(10, 20, 40, 0.08);
            border: 1px solid rgba(13, 34, 80, 0.04);
        }

        path.country:hover {
            stroke: #06283d;
            stroke-width: 1.2px;
            opacity: 0.98;
            cursor: pointer;
        }

        .tooltip {
            font-size: 13px;
            line-height: 1.3;
            color: #041127;
            background: white;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 8px 20px rgba(12, 34, 64, 0.12);
            border: 1px solid rgba(10, 30, 60, 0.06);
            pointer-events: none;
            transition: opacity 160ms ease-out, transform 160ms ease-out;
        }

        .legend text {
            font-size: 12px;
            fill: #0b2b4a;
        }

        /* Responsive: scale down on small screens */
        @media (max-width: 700px) {
            body { padding: 14px; }
            #choropleth { width: 100% !important; height: auto !important; }
        }
        /* Responsive layout for map + scatter side-by-side */
        #viz-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: nowrap;
        }
        #map-wrapper {
            flex: 0 0 60%;
            min-width: 320px;
        }
        #scatterplot {
            flex: 0 0 38%;
            min-width: 280px;
        }
        @media (max-width: 1000px) {
            #viz-container { flex-wrap: wrap; }
            #map-wrapper, #scatterplot { flex: 0 0 100%; }
            #map-wrapper { order: 0; }
            #scatterplot { order: 1; }
        }
    </style>
</head>


<body>
    <div class="container">
        <!-- Add heading for the visualization -->
        <h2>Food Nutrition Indices: Data Visualization</h2>
        <div style="display:flex;justify-content:center;gap:12px;align-items:center;margin-bottom:16px;font-size:14px;">
            <label for="metric-select" style="font-weight:600;color:#0b3d91;">Metric:</label>
            <select id="metric-select" style="min-width:190px;padding:6px 10px;border-radius:6px;border:1px solid #cdd3de;">
                <option value="nutrition" selected>Nutrition Score</option>
                <option value="protein">Protein</option>
                <option value="fat">Fats</option>
                <option value="carbohydrates">Carbohydrates</option>
            </select>
            <label for="colorMode" style="font-weight:600;color:#0b3d91;margin-left:8px;">Color Mode:</label>
            <select id="colorMode" style="min-width:160px;padding:6px 10px;border-radius:6px;border:1px solid #cdd3de;">
                <option value="nutrition">Individual</option>
                <option value="cluster">Cluster</option>
            </select>
        </div>
    

    <script>
        // enter code to define margin and dimensions for svg
        const margin = {top: 50, right: 0, bottom: 50, left: 100};
        const width = 1050 - margin.left - margin.right;
        const height = 600 - margin.top - margin.bottom;
        
        const container = d3.select('body')
            .append('div')
            .attr('id', 'viz-container')
            .style('display', 'flex')
            .style('gap', '20px')
            .style('flex-wrap', 'wrap');

        const mapWrapper = container.append('div')
            .attr('id', 'map-wrapper')
            .style('display', 'flex')
            .style('flex-direction', 'column');

        const defaultInfoMessage = 'Hover over a country or scatter point to see details. Use the dropdown to switch metrics.';
        const infoPanel = mapWrapper.append('div')
            .attr('id', 'map-info')
            .style('padding', '8px 12px')
            .style('background', '#f5f5f5')
            .style('border', '1px solid #ccc')
            .style('border-radius', '4px')
            .style('min-height', '60px')
            .style('margin-bottom', '8px')
            .style('font-family', 'sans-serif')
            .style('font-size', '14px')
            .html(defaultInfoMessage);

        const svg1 = mapWrapper.append('svg')
            .attr('id', 'choropleth')
            .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
            .attr('preserveAspectRatio', 'xMidYMid meet')
            .style('width', '100%')
            .style('height', 'auto');
            

        const svg = svg1.append('g')
            .attr('id', 'countries')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        var projection = d3.geoNaturalEarth()
            .scale(200)
            .translate([width / 2 - 100, height / 1.5 - 100]);
        var path = d3.geoPath().projection(projection);

        const scatterMargin = {top: 50, right: 30, bottom: 70, left: 80};
        const scatterWidth = 600 - scatterMargin.left - scatterMargin.right;
        const scatterHeight = 600 - scatterMargin.top - scatterMargin.bottom;

        const scatterSvg = container.append('svg')
            .attr('id', 'scatterplot')
            .attr('viewBox', `0 0 ${scatterWidth + scatterMargin.left + scatterMargin.right} ${scatterHeight + scatterMargin.top + scatterMargin.bottom}`)
            .attr('preserveAspectRatio', 'xMidYMid meet')
            .style('width', '100%')
            .style('height', 'auto');

        const scatterGroup = scatterSvg.append('g')
            .attr('transform', `translate(${scatterMargin.left},${scatterMargin.top})`);
        // Scatter plot title
        scatterGroup.append('text')
            .attr('class', 'scatter-title')
            .attr('x', scatterWidth / 2)
            .attr('y', -scatterMargin.top / 2)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .style('font-weight', 700)
            .style('fill', '#0b3d91')
            .text('Plot of countries across various statistic types');
        const xScale = d3.scaleLog().range([0, scatterWidth]);
        const yScale = d3.scaleLinear().range([scatterHeight, 0]);
        const scatterXAxis = scatterGroup.append('g')
            .attr('class', 'x-axis')
            .attr('transform', `translate(0,${scatterHeight})`);
        const scatterYAxis = scatterGroup.append('g')
            .attr('class', 'y-axis');
        scatterGroup.append('text')
            .attr('x', scatterWidth / 2)
            .attr('y', scatterHeight + scatterMargin.bottom - 25)
            .attr('text-anchor', 'middle')
            .text('GDP per capita (PPP)');
        const scatterYLabel = scatterGroup.append('text')
            .attr('transform', 'rotate(-90)')
            .attr('x', -scatterHeight / 2)
            .attr('y', -scatterMargin.left + 20)
            .attr('text-anchor', 'middle')
            .text('Nutrition Score Rank');

        const gdpFormat = d3.format(',.0f');
        const metricFormatters = {
            nutrition: d3.format('.2f'),
            default: d3.format(',.0f')
        };
        let selectedMetric = 'nutrition';
        let metricStates = {};
        let currentMetricState = null;
        let mapPaths = null;
        let scatterDots = null;
        let scatterData = [];
        let countryInfo = {};
        let currentColorMode = 'nutrition';
        let clusterMap = {};
        let tooltip = null;

        function updateInfoPanel(iso, fallbackName) {
            if (!iso || !currentMetricState) {
                infoPanel.html(defaultInfoMessage);
                return;
            }
            const info = countryInfo[iso] || {};
            const name = info.name || fallbackName || 'Unknown';
            const metric = currentMetricState;
            const value = metric.values[iso];
            const rank = metric.ranks[iso];
            if (selectedMetric === 'nutrition') {
                const scoreText = value != null ? metric.formatter(value) : 'N/A';
                const gdpText = info.gdp ? gdpFormat(info.gdp) : 'N/A';
                infoPanel.html(`<strong>${name}</strong><br/>Nutrition Score: ${scoreText}<br/>GDP per capita: ${gdpText}`);
            } else if (rank != null) {
                infoPanel.html(`<strong>${name}</strong><br/>${metric.label} Rank: #${rank}`);
            } else {
                infoPanel.html(`<strong>${name}</strong><br/>No data for selected metric.`);
            }
        }

        function highlightCountry(iso, fallbackName) {
            if (mapPaths) {
                mapPaths
                    .attr('stroke-width', d => d.id === iso ? 3 : 0.6)
                    .attr('stroke', d => d.id === iso ? 'black' : '#333')
                    .attr('fill', function(d) { return d.id === iso ? '#ff9900' : (this._defaultFill || '#ccc'); })
                if (iso) {
                    mapPaths.filter(d => d.id === iso).raise();
                }
            }
            if (scatterDots) {
                scatterDots
                    .attr('r', d => d.iso === iso ? 6 : 4)
                    .attr('fill', d => {
                        if (d.iso === iso) return '#ff9900'; // should be vibrant orange for hovered country
                        if (currentColorMode === 'nutrition') return '#2c7fb8';
                        if (currentColorMode === 'cluster') return clusterMap[d.iso] ? clusterMap[d.iso].color : '#ccc';
                        return '#ccc';
                    })
                    .attr('stroke-width', d => d.iso === iso ? 2 : 0.6)
                    .attr('stroke', d => d.iso === iso ? 'black' : '#333')
            }
            updateInfoPanel(iso, fallbackName);
        }

        function showTooltip(evt, iso) {
            if (!currentMetricState) return;
            const metric = currentMetricState;
            const value = metric.values[iso];
            const rank = metric.ranks[iso];
            let content = '';
            if (selectedMetric === 'nutrition') {
                content = value != null ? `${metric.label}: ${metric.formatter(value)}` : '';
            } else if (rank != null) {
                content = `${metric.label} Rank: #${rank}`;
            }
            if (!content) {
                tooltip.style('opacity', 0);
                return;
            }
            tooltip
                .style('opacity', 0.95)
                .html(content)
                .style('left', `${evt.pageX + 12}px`)
                .style('top', `${evt.pageY - 28}px`);
        }
        function hideTooltip() {
            tooltip.style('opacity', 0);
        }

        function loadGdpData(path) {
            return d3.text(path).then(raw => {
                const lines = raw.split(/\r?\n/);
                const headerIndex = lines.findIndex(line => line.startsWith('"Country Name"'));
                if (headerIndex === -1) {
                    console.warn('GDP header row not found.');
                    return [];
                }
                const cleaned = lines.slice(headerIndex).join('\n');
                return d3.csvParse(cleaned);
            });
        }

        Promise.all([
            d3.json('./data/world_countries.json'),
            d3.csv('./data/country_nutrition_scores.csv'),
            loadGdpData('./data/API_NY.GDP.PCAP.PP.CD_DS2_en_csv_v2_254072.csv'),
            d3.csv('./data/country_nutrient_totals.csv'),
            d3.csv('./data/area_cluster_colors.csv')
        ]).then(([world, nutritionScores, gdpRows, nutrientTotals, clusterCountries]) => {
            ready(world, nutritionScores, gdpRows, nutrientTotals, clusterCountries);
        });
        
        // this function should be called once the data from files have been read
        // world: topojson from world_countries.json
        function ready(world, nutritionScores, gdpRows, nutrientTotals, clusterCountries) {
            const nutrMap = buildValueMap(nutritionScores, d => +d['Nutrition Score']);
            const isoLookup = nutritionScores.reduce((acc, d) => {
                acc[d.Area] = d.ISO3;
                return acc;
            }, {});
            const isoNutrients = {};
            nutrientTotals.forEach(row => {
                const iso = isoLookup[row.Area];
                if (!iso) return;
                isoNutrients[iso] = row;
            });
            const proteinValues = buildNutrientValues(isoNutrients, 'Protein');
            const fatValues = buildNutrientValues(isoNutrients, 'Fat');
            const carbValues = buildNutrientValues(isoNutrients, 'Carbohydrates');
            registerMetric('nutrition', 'Nutrition Score', nutrMap, metricFormatters.nutrition);
            registerMetric('protein', 'Protein', proteinValues);
            registerMetric('fat', 'Fat', fatValues);
            registerMetric('carbohydrates', 'Carbohydrates', carbValues);
            const gdpMap = buildGdpMap(gdpRows);
            countryInfo = nutritionScores.reduce((acc, d) => {
                acc[d.ISO3] = { name: d.Area, score: nutrMap[d.ISO3], gdp: gdpMap[d.ISO3] };
                return acc;
            }, {});

            clusterMap = {};
            clusterCountries.forEach(d => {
                clusterMap[d.ISO3] = {
                    cluster: d.Cluster,
                    color: d.Cluster_Color
                };
            });
            currentMetricState = metricStates[selectedMetric];
            createMapAndLegend(world, nutrMap, gdpMap);
            createScatterPlot(nutritionScores, gdpMap);
            d3.select("#colorMode").on("change", function() {
                currentColorMode = d3.select(this).property("value");
                
                if (currentColorMode === "nutrition") {
                    mapPaths
                        .transition().duration(400)
                        .attr("fill", function(d) {
                            const score = nutrMap[d.id];
                            const fillVal = score !== undefined ? d3.interpolateYlGnBu(score / 100) : "#ccc";
                            this._defaultFill = fillVal;
                            return fillVal;
                        });

                    scatterDots
                        .transition().duration(400)
                        .attr('fill', '#2c7fb8')
                        .attr('opacity', 0.75);

                    createLegendNutrition(metricStates['nutrition']);
                    
                } else if (currentColorMode === "cluster") {
                    mapPaths
                        .transition().duration(400)
                        .attr("fill", function(d) {
                            const fillVal = clusterMap[d.id] ? clusterMap[d.id].color : "#ccc";
                            this._defaultFill = fillVal;
                            return fillVal;
                        });

                    scatterDots
                        .transition().duration(400)
                        .attr('fill', d => clusterMap[d.iso] ? clusterMap[d.iso].color : '#ccc')
                        .attr('opacity', 0.85);

                    createLegendCluster(clusterMap);
                }
            });
            renderMetric();
            d3.select('#metric-select').on('change', function() {
                selectedMetric = this.value;
                currentMetricState = metricStates[selectedMetric];
                renderMetric();
            });
        }

        function buildValueMap(rows, accessor) {
            return rows.reduce((acc, row) => {
                const value = accessor(row);
                if (!isNaN(value)) {
                    acc[row.ISO3] = value;
                }
                return acc;
            }, {});
        }
        function buildNutrientValues(isoNutrients, column) {
            const result = {};
            Object.entries(isoNutrients).forEach(([iso, row]) => {
                const value = +row[column];
                if (!isNaN(value)) {
                    result[iso] = value;
                }
            });
            return result;
        }
        function registerMetric(id, label, values, formatter = metricFormatters.default) {
            const extentValues = Object.values(values).filter(v => v != null && !isNaN(v));
            const extent = extentValues.length ? d3.extent(extentValues) : [0, 1];
            if (extent[0] === extent[1]) {
                extent[1] = extent[0] + 1;
            }
            const { ranks, maxRank } = createRanking(values);
            metricStates[id] = { id, label, values, ranks, extent, maxRank, formatter };
        }
        function createRanking(values) {
            const entries = Object.entries(values).filter(([, v]) => v != null && !isNaN(v));
            entries.sort((a, b) => b[1] - a[1]);
            const ranks = {};
            let prevValue = null;
            let currentRank = 0;
            entries.forEach(([iso, value], idx) => {
                if (value !== prevValue) {
                    currentRank = idx + 1;
                    prevValue = value;
                }
                ranks[iso] = currentRank;
            });
            return { ranks, maxRank: entries.length };
        }
        function buildGdpMap(rows) {
            const gdpMap = {};
            rows.forEach(row => {
                const years = Object.keys(row).filter(k => /^\d{4}$/.test(k)).sort((a, b) => b - a);
                for (const year of years) {
                    const value = parseFloat(row[year]);
                    if (!isNaN(value) && value > 0) {
                        gdpMap[row['Country Code']] = value;
                        break;
                    }
                }
            });
            return gdpMap;
        }

        // this function should create a Choropleth map
        function createMapAndLegend(world, nutrMap, gdpMap){ 
            svg.selectAll("*").remove();

            const color = d3.scaleSequential()
                .domain(d3.extent(Object.values(nutrMap)))
                .interpolator(d3.interpolateYlGnBu);
            tooltip = d3.select("body").select(".tooltip");
            if (tooltip.empty()) {
                tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip")
                    .style("position", "absolute")
                    .style("padding", "6px 10px")
                    .style("background", "white")
                    .style("border", "1px solid #ccc")
                    .style("border-radius", "4px")
                    .style("pointer-events", "none")
                    .style("opacity", 0)
                    .style("z-index", 9999)
                    .style("max-width", "300px");
            }

            // keep reference to paths for highlightCountry
            mapPaths = svg.selectAll("path")
                .data(world.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("stroke", "#333")
                .attr("stroke-width", 0.5)
                .each(function(d) {
                    const score = nutrMap[d.id];
                    const fillVal = score !== undefined ? color(score) : "#ccc";
                    d.defaultFill = fillVal;
                    this._defaultFill = fillVal;
                })
                .attr("fill", function(d) { return this._defaultFill || '#ccc'; })
                .on("mouseover", function(d) {
                    const iso = d.id;
                    highlightCountry(iso, d.properties.name);
                    const evt = d3.event;
                    showTooltip(evt, iso);
                })
                .on('mousemove', function(d) {
                    const evt = d3.event;
                    showTooltip(evt, d.id);
                })
                .on('mouseout', function() {
                    highlightCountry(null);
                    hideTooltip();
                });
        }
        function getColorScale(metricState) {
            return d3.scaleSequential()
                .domain(metricState.extent)
                .interpolator(d3.interpolateYlGnBu);
        }
        function updateMapColors(metricState) {
            if (!mapPaths) return;
            if (currentColorMode === 'cluster') {
                mapPaths.attr('fill', function(d) {
                    const fill = clusterMap[d.id] ? clusterMap[d.id].color : '#ccc';
                    this._defaultFill = fill;
                    return fill;
                });
                return;
            }
            const color = getColorScale(metricState);
            mapPaths.attr('fill', function(d) {
                const value = metricState.values[d.id];
                const fill = value != null && !isNaN(value) ? color(value) : '#ccc';
                this._defaultFill = fill;
                return fill;
            });
        }
        function updateLegend(metricState) {
            svg.selectAll('.legend').remove();
            svg.select('#legend-gradient').remove();
            if (!metricState) return;
            if (currentColorMode === 'cluster') {
                createLegendCluster(clusterMap);
            } else {
                createLegendNutrition(metricState);
            }
        }

        function createLegendNutrition(metricState) {
            svg.selectAll('.legend').remove();
            svg.select('#legend-gradient').remove();
            if (!metricState) return;

            const color = getColorScale(metricState);
            const extent = metricState.extent;

            const defs = svg.select('defs').empty() ? svg.append('defs') : svg.select('defs');
            defs.select('#legend-gradient').remove();

            const gradient = defs.append('linearGradient')
                .attr('id', 'legend-gradient')
                .attr('x1', '0%').attr('x2', '0%').attr('y1', '100%').attr('y2', '0%');

            const stops = [0, 0.25, 0.5, 0.75, 1];
            stops.forEach(t => {
                const value = extent[0] + t * (extent[1] - extent[0]);
                gradient.append('stop')
                    .attr('offset', `${t * 100}%`)
                    .attr('stop-color', color(value));
            });

            const legendHeight = Math.min(300, height * 0.75);
            const legendWidth = 40;
            const legendX = Math.max(width - 160, width - legendWidth - 60);
            const legendY = (height - legendHeight) / 2 - 100;

            const legendG = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${legendX}, ${legendY})`)
                .attr('pointer-events', 'none')
                .style('filter', 'url(#legend-drop)');

            // background panel
            legendG.append('rect')
                .attr('x', -12)
                .attr('y', -18)
                .attr('width', 120)
                .attr('height', legendHeight + 36)
                .attr('rx', 8)
                .attr('ry', 8)
                .style('fill', '#ffffff')
                .style('fill-opacity', 0.92)
                .style('stroke', 'black')
                .style('stroke-width', 1);

            // colored gradient bar
            legendG.append('rect')
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .style('fill', 'url(#legend-gradient)')
                .style('stroke', '#666')
                .style('stroke-width', 1.2)
                .style('rx', 3)
                .style('ry', 3);

            const showNumericTicks = metricState.id === 'nutrition';
            if (showNumericTicks) {
                const ticks = 5;
                const formatter = metricState.formatter || metricFormatters.default;
                d3.range(ticks).forEach(i => {
                    const frac = i / (ticks - 1);
                    const value = extent[0] + frac * (extent[1] - extent[0]);
                    legendG.append('text')
                        .attr('x', legendWidth + 12)
                        .attr('y', (1 - frac) * legendHeight + 5)
                        .style('font-size', '13px')
                        .style('font-weight', 600)
                        .text(formatter(value));
                });
            } else {
                // For rank-based metrics, show five ticks (or fewer if maxRank < 5)
                const maxRank = metricState.maxRank || Math.max(1, Math.round(extent[1]));
                const ticks = Math.min(5, Math.max(2, maxRank));
                const ranks = [];
                for (let i = 0; i < ticks; i++) {
                    const rk = Math.round(1 + i * (maxRank - 1) / (ticks - 1));
                    if (!ranks.includes(rk)) ranks.push(rk);
                }
                const denom = Math.max(1, (maxRank - 1));
                ranks.forEach(rk => {
                    const y = ((rk - 1) / denom) * legendHeight + 5;
                    legendG.append('line')
                        .attr('x1', legendWidth)
                        .attr('x2', legendWidth + 6)
                        .attr('y1', y)
                        .attr('y2', y)
                        .style('stroke', '#041127')
                        .style('stroke-width', 1);
                    legendG.append('text')
                        .attr('x', legendWidth + 12)
                        .attr('y', y + 4)
                        .style('font-size', '13px')
                        .style('font-weight', 600)
                        .text(`#${rk}`);
                });
            }

            legendG.append('text')
                .attr('x', legendWidth / 2 + 25)
                .attr('y', -30)
                .attr('text-anchor', 'middle')
                .style('font-size', '13px')
                .style('font-weight', '700')
                .text(metricState.label);
        }

        function updateScatterPlot(metricState) {
            if (!scatterDots || !metricState) return;
            if (metricState.id === 'nutrition') {
                const vals = Object.values(metricState.values).filter(v => v != null && !isNaN(v));
                const extentVals = vals.length ? d3.extent(vals) : [0, 1];
                const pad = (extentVals[1] - extentVals[0]) * 0.05;
                yScale.domain([extentVals[1] + pad, Math.max(0, extentVals[0] - pad)]);

                scatterDots.transition().duration(600)
                    .attr('cx', d => xScale(d.gdp))
                    .attr('cy', d => {
                        const val = metricState.values[d.iso];
                        return val != null && !isNaN(val) ? yScale(val) : scatterHeight;
                    })
                    .attr('fill', d => {
                        if (currentColorMode === 'cluster') return clusterMap[d.iso] ? clusterMap[d.iso].color : '#ccc';
                        return '#2c7fb8';
                    })
                    .attr('opacity', currentColorMode === 'cluster' ? 0.85 : 0.75);

                scatterYAxis.call(d3.axisLeft(yScale).ticks(6).tickFormat(metricState.formatter || metricFormatters.default));
                scatterYLabel.text(metricState.label);
            } else {
                const maxRank = metricState.maxRank || 1;
                yScale.domain([maxRank, 1]);

                scatterDots.transition().duration(600)
                    .attr('cx', d => xScale(d.gdp))
                    .attr('cy', d => {
                        const rank = metricState.ranks[d.iso];
                        return rank ? yScale(rank) : scatterHeight;
                    })
                    .attr('fill', d => {
                        if (currentColorMode === 'cluster') return clusterMap[d.iso] ? clusterMap[d.iso].color : '#ccc';
                        return '#2c7fb8';
                    })
                    .attr('opacity', currentColorMode === 'cluster' ? 0.85 : 0.75);

                scatterYAxis.call(d3.axisLeft(yScale).ticks(6).tickFormat(d3.format('d')));
                scatterYLabel.text(metricState.label + ' Rank');
            }
        }

        function renderMetric() {
            if (!currentMetricState) return;
            updateMapColors(currentMetricState);
            updateLegend(currentMetricState);
            updateScatterPlot(currentMetricState);
            updateInfoPanel(null);
            hideTooltip();
        }
        
        function createScatterPlot(nutritionScores, gdpMap) {
            scatterData = nutritionScores
                .map(d => {
                    const rawGdp = gdpMap[d.ISO3];
                    if (rawGdp == null || rawGdp < 0) return null;
                    const gdp = Math.min(200000, Math.max(1, rawGdp));
                    return { iso: d.ISO3, name: d.Area, gdp };
                })
                .filter(Boolean);
            const minGdp = d3.min(scatterData, d => d.gdp) || 1;
            xScale.domain([Math.min(minGdp, 200000), 200000]).nice();
            scatterXAxis.call(
                d3.axisBottom(xScale)
                    .ticks(6, '~s')
            );
            scatterDots = scatterGroup.selectAll('.dot')
                .data(scatterData, d => d.iso)
                .enter()
                .append('circle')
                .attr('class', 'dot')
                .attr('cx', d => xScale(d.gdp))
                .attr('cy', scatterHeight)
                .attr('r', 4)
                .attr('fill', '#2c7fb8')
                .attr('opacity', 0.75)
                .on('mouseover', function(d) {
                    highlightCountry(d.iso, d.name);
                })
                .on('mouseout', () => {
                    highlightCountry(null);
                });
        }
    
        function createMapAndLegendCluster(world, clusterMap) {
            svg.selectAll("*").remove(); // clear previous map and legend

            // draw countries
            mapPaths = svg.selectAll("path")
                .data(world.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("stroke", "#333")
                .attr("stroke-width", 0.5)
                .each(function(d) {
                    const fillVal = clusterMap[d.id] ? clusterMap[d.id].color : "#ccc";
                    d.defaultFill = fillVal;
                    this._defaultFill = fillVal;
                })
                .attr("fill", function(d) { return this._defaultFill || '#ccc'; })
                .on("mouseover", function(d) {
                    const info = clusterMap[d.id];
                    const text = info ? `Cluster ${info.cluster}` : "No data";
                    infoPanel.html(`<strong>${d.properties.name}</strong><br/>${text}`);
                })
                .on("mouseout", function() {
                    infoPanel.html('Hover over a country or scatter point to see details.');
                });
        }
    
        function createLegendCluster(clusterMap) {
            svg.selectAll('.legend').remove();

            const clusters = Array.from(new Set(Object.values(clusterMap).map(d => d.cluster))).sort((a, b) => a - b);

            // legend sizing
            const legendWidth = 40;
            const legendHeight = clusters.length * 27;
            const legendX = Math.max(width - 160, width - legendWidth - 80);
            const legendY = (height - legendHeight) / 2 - 140;

            // legend group
            const legendG = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${legendX}, ${legendY})`)
                .style('filter', 'url(#legend-drop)')
                .attr('pointer-events', 'none');

            // background panel
            legendG.append('rect')
                .attr('x', -12)
                .attr('y', -18)
                .attr('width', 150)
                .attr('height', legendHeight + 36)
                .attr('rx', 8)
                .attr('ry', 8)
                .style('fill', '#ffffff')
                .style('fill-opacity', 0.92)
                .style('stroke', 'black')
                .style('stroke-width', 1);

            // draw rectangles for each cluster
            clusters.forEach((c, i) => {
                const color = Object.values(clusterMap).find(d => d.cluster == c).color;

                legendG.append('rect')
                    .attr('x', 0)
                    .attr('y', i * 30)
                    .attr('width', legendWidth)
                    .attr('height', 20)
                    .attr('rx', 3)
                    .attr('ry', 3)
                    .attr('fill', color)
                    .style('stroke', '#666')
                    .style('stroke-width', 1.2);

                legendG.append('text')
                    .attr('x', legendWidth + 10)
                    .attr('y', i * 30 + 15)
                    .text(`Cluster ${c}`)
                    .style('font-size', '13px')
                    .style('fill', '#041127')
                    .style('font-weight', 600);
            });

            // legend title
            legendG.append('text')
                .attr('x', 30)
                .attr('y', -25)
                .style('font-weight', '700')
                .style('font-size', '13px')
                .style('fill', '#041127')
                .text('Clusters');
        }

    </script>
    </div>
</body>

</html>

<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <!-- add title -->
    <title>Food Nutrition Indices: Data Visualization</title>
    
    <!-- import required libraries here -->
    <script type="text/javascript" src="../lib/d3.v5.min.js"></script>
    <script type="text/javascript" src="../lib/d3-dsv.min.js"></script>
    <script type="text/javascript" src="../lib/topojson.v2.min.js"></script>
    <script type="text/javascript" src="../lib/d3-tip.min.js"></script>
    <script type="text/javascript" src="../lib/d3-legend.min.js"></script>
    <script type="text/javascript" src="../lib/d3-geo-projection.v2.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Page layout */
        body { 
            margin: 0; 
            padding: 28px; 
            background: linear-gradient(180deg, #f7fbff 0%, #eef6fb 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
            color: #0f1724;
        }
        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 10px 16px 40px 16px;
        }
        h2 {
            text-align: center;
            margin: 6px 0 20px;
            font-weight: 600;
            color: #0b3d91;
            letter-spacing: -0.2px;
        }

        #choropleth {
            display: block;
            margin: 0 auto 12px auto;
            background: linear-gradient(180deg, #ffffff 0%, #fbfdff 100%);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(10, 20, 40, 0.08);
            border: 1px solid rgba(13, 34, 80, 0.04);
        }

        path.country:hover {
            stroke: #06283d;
            stroke-width: 1.2px;
            opacity: 0.98;
            cursor: pointer;
        }

        .tooltip {
            font-size: 13px;
            line-height: 1.3;
            color: #041127;
            background: white;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 8px 20px rgba(12, 34, 64, 0.12);
            border: 1px solid rgba(10, 30, 60, 0.06);
            pointer-events: none;
            transition: opacity 160ms ease-out, transform 160ms ease-out;
        }

        .legend text {
            font-size: 12px;
            fill: #0b2b4a;
        }

        /* Responsive: scale down on small screens */
        @media (max-width: 700px) {
            body { padding: 14px; }
            #choropleth { width: 100% !important; height: auto !important; }
        }
        /* Responsive layout for map + scatter side-by-side */
        #viz-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: nowrap;
        }
        #map-wrapper {
            flex: 0 0 60%;
            min-width: 320px;
        }
        #scatterplot {
            flex: 0 0 38%;
            min-width: 280px;
        }
        @media (max-width: 1000px) {
            #viz-container { flex-wrap: wrap; }
            #map-wrapper, #scatterplot { flex: 0 0 100%; }
            #map-wrapper { order: 0; }
            #scatterplot { order: 1; }
        }
    </style>
</head>


<body>
    <div class="container">
        <!-- Add heading for the visualization -->
        <h2>Food Nutrition Indices: Data Visualization</h2>

        <label for="colorMode">Color Mode:</label>
        <select id="colorMode">
            <option value="nutrition">Nutrition Score</option>
            <option value="cluster">Cluster</option>
        </select>
    

    <script>
        // enter code to define margin and dimensions for svg
        const margin = {top: 50, right: 0, bottom: 50, left: 100};
        const width = 1050 - margin.left - margin.right;
        const height = 600 - margin.top - margin.bottom;
        
        const container = d3.select('body')
            .append('div')
            .attr('id', 'viz-container')
            .style('display', 'flex')
            .style('gap', '20px')
            .style('flex-wrap', 'wrap');

        const mapWrapper = container.append('div')
            .attr('id', 'map-wrapper')
            .style('display', 'flex')
            .style('flex-direction', 'column');

        const defaultInfoMessage = 'Hover over a country or scatter point to see details.';
        const infoPanel = mapWrapper.append('div')
            .attr('id', 'map-info')
            .style('padding', '8px 12px')
            .style('background', '#f5f5f5')
            .style('border', '1px solid #ccc')
            .style('border-radius', '4px')
            .style('min-height', '60px')
            .style('margin-bottom', '8px')
            .style('font-family', 'sans-serif')
            .style('font-size', '14px')
            .html(defaultInfoMessage);

        const svg1 = mapWrapper.append('svg')
            .attr('id', 'choropleth')
            .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
            .attr('preserveAspectRatio', 'xMidYMid meet')
            .style('width', '100%')
            .style('height', 'auto');
            

        const svg = svg1.append('g')
            .attr('id', 'countries')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        var projection = d3.geoNaturalEarth()
            .scale(200)
            .translate([width / 2 - 100, height / 1.5 - 100]);
        var path = d3.geoPath().projection(projection);

        const scatterMargin = {top: 50, right: 30, bottom: 70, left: 80};
        const scatterWidth = 600 - scatterMargin.left - scatterMargin.right;
        const scatterHeight = 600 - scatterMargin.top - scatterMargin.bottom;

        const scatterSvg = container.append('svg')
            .attr('id', 'scatterplot')
            .attr('viewBox', `0 0 ${scatterWidth + scatterMargin.left + scatterMargin.right} ${scatterHeight + scatterMargin.top + scatterMargin.bottom}`)
            .attr('preserveAspectRatio', 'xMidYMid meet')
            .style('width', '100%')
            .style('height', 'auto');

        const scatterGroup = scatterSvg.append('g')
            .attr('transform', `translate(${scatterMargin.left},${scatterMargin.top})`);

        const gdpFormat = d3.format(',.0f');
        let mapPaths = null;
        let scatterDots = null;
        let countryInfo = {};
        // hoisted globals so other functions (highlightCountry, handlers) can access
        let currentColorMode = 'nutrition';
        let clusterMap = {};

        function updateInfoPanel(iso, fallbackName) {
            const info = iso ? countryInfo[iso] : null;
            if (!info) {
                infoPanel.html(defaultInfoMessage);
                return;
            }
            const name = info.name || fallbackName || 'Unknown';
            const scoreText = info.score !== undefined ? info.score.toFixed(2) : 'N/A';
            const gdpText = info.gdp ? gdpFormat(info.gdp) : 'N/A';
            infoPanel.html(`<strong>${name}</strong><br/>Nutrition Score: ${scoreText}<br/>GDP per capita: ${gdpText}`);
        }

        function highlightCountry(iso, fallbackName) {
            if (mapPaths) {
                mapPaths
                    .attr('stroke-width', d => d.id === iso ? 3 : 0.6)
                    .attr('stroke', d => d.id === iso ? 'black' : '#333')
                    .attr('fill', function(d) { return d.id === iso ? '#ff9900' : (this._defaultFill || '#ccc'); })
                if (iso) {
                    mapPaths.filter(d => d.id === iso).raise();
                }
            }
            if (scatterDots) {
                scatterDots
                    .attr('r', d => d.iso === iso ? 6 : 4)
                    .attr('fill', d => {
                        if (d.iso === iso) return '#ff9900'; // orange for hovered country
                        if (currentColorMode === 'nutrition') return '#2c7fb8';
                        if (currentColorMode === 'cluster') return clusterMap[d.iso] ? clusterMap[d.iso].color : '#ccc';
                        return '#ccc';
                    })
                    .attr('stroke-width', d => d.iso === iso ? 2 : 0.6)
                    .attr('stroke', d => d.iso === iso ? 'black' : '#333')
            }
            updateInfoPanel(iso, fallbackName);
        }

        function loadGdpData(path) {
            return d3.text(path).then(raw => {
                const lines = raw.split(/\r?\n/);
                const headerIndex = lines.findIndex(line => line.startsWith('"Country Name"'));
                if (headerIndex === -1) {
                    console.warn('GDP header row not found.');
                    return [];
                }
                const cleaned = lines.slice(headerIndex).join('\n');
                return d3.csvParse(cleaned);
            });
        }

        Promise.all([
            d3.json('./data/world_countries.json'),
            d3.csv('./data/country_nutrition_scores.csv'),
            loadGdpData('./data/API_NY.GDP.PCAP.PP.CD_DS2_en_csv_v2_254072.csv'),
            d3.csv('./data/area_cluster_colors.csv')
        ]).then(([world, nutritionScores, gdpRows, clusterCountries]) => {
            ready(world, nutritionScores, gdpRows, clusterCountries);
        });
        
        // this function should be called once the data from files have been read
        // world: topojson from world_countries.json
        function ready(world, nutritionScores, gdpRows, clusterCountries) {
            const nutrMap = {};
            nutritionScores.forEach(d => {
                nutrMap[d.ISO3] = +d['Nutrition Score'];
            });

            const gdpMap = buildGdpMap(gdpRows);
            countryInfo = nutritionScores.reduce((acc, d) => {
                acc[d.ISO3] = {
                    name: d.Area,
                    score: +d['Nutrition Score'],
                    gdp: gdpMap[d.ISO3]
                };
                return acc;
            }, {});

            // populate hoisted clusterMap
            clusterMap = {};
            clusterCountries.forEach(d => {
                clusterMap[d.ISO3] = {
                    cluster: d.Cluster,
                    color: d.Cluster_Color
                };
            });
            createMapAndLegend(world, nutrMap, gdpMap);
            createScatterPlot(nutritionScores, gdpMap);
            d3.select("#colorMode").on("change", function() {
                currentColorMode = d3.select(this).property("value");
                
                if (currentColorMode === "nutrition") {
                    mapPaths
                        .transition().duration(400)
                        .attr("fill", function(d) {
                            const score = nutrMap[d.id];
                            const fillVal = score !== undefined ? d3.interpolateYlGnBu(score / 100) : "#ccc";
                            this._defaultFill = fillVal;
                            return fillVal;
                        });

                    scatterDots
                        .transition().duration(400)
                        .attr('fill', '#2c7fb8')
                        .attr('opacity', 0.75);

                    createLegendNutrition(nutrMap);
                    
                } else if (currentColorMode === "cluster") {
                    mapPaths
                        .transition().duration(400)
                        .attr("fill", function(d) {
                            const fillVal = clusterMap[d.id] ? clusterMap[d.id].color : "#ccc";
                            this._defaultFill = fillVal;
                            return fillVal;
                        });

                    scatterDots
                        .transition().duration(400)
                        .attr('fill', d => clusterMap[d.iso] ? clusterMap[d.iso].color : '#ccc')
                        .attr('opacity', 0.85);

                    createLegendCluster(clusterMap);
                }
            });
        }

        function buildGdpMap(rows) {
            const gdpMap = {};
            rows.forEach(row => {
                const years = Object.keys(row).filter(k => /^\d{4}$/.test(k)).sort((a, b) => b - a);
                for (const year of years) {
                    const value = parseFloat(row[year]);
                    if (!isNaN(value) && value > 0) {
                        gdpMap[row['Country Code']] = value;
                        break;
                    }
                }
            });
            return gdpMap;
        }

        // this function should create a Choropleth map
        function createMapAndLegend(world, nutrMap, gdpMap){ 
            svg.selectAll("*").remove();

            const color = d3.scaleSequential()
                .domain(d3.extent(Object.values(nutrMap)))
                .interpolator(d3.interpolateYlGnBu);
            // ensure tooltip exists (create once)
            let tooltip = d3.select("body").select(".tooltip");
            if (tooltip.empty()) {
                tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip")
                    .style("position", "absolute")
                    .style("padding", "6px 10px")
                    .style("background", "white")
                    .style("border", "1px solid #ccc")
                    .style("border-radius", "4px")
                    .style("pointer-events", "none")
                    .style("opacity", 0)
                    .style("z-index", 9999)
                    .style("max-width", "300px");
            }

            // keep reference to paths for highlightCountry
            mapPaths = svg.selectAll("path")
                .data(world.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("stroke", "#333")
                .attr("stroke-width", 0.5)
                .each(function(d) {
                    const score = nutrMap[d.id];
                    const fillVal = score !== undefined ? color(score) : "#ccc";
                    d.defaultFill = fillVal;
                    this._defaultFill = fillVal;
                })
                .attr("fill", function(d) { return this._defaultFill || '#ccc'; })
                .on("mouseover", function(d) {
                    const iso = d.id;
                    highlightCountry(iso, d.properties.name);
                    // show tooltip near mouse
                    const score = (nutrMap[d.id] !== undefined) ? nutrMap[d.id].toFixed(2) : 'N/A';
                })
                .on("mouseout", function() {
                    highlightCountry(null);
                });
        }

        function createLegendNutrition(nutrMap) {
            svg.selectAll('.legend').remove();

            const values = Object.values(nutrMap).filter(v => v != null && !isNaN(v));
            let minVal = 0, maxVal = 100;
            if (values.length > 0) {
                const extent = d3.extent(values);
                minVal = extent[0];
                maxVal = extent[1];
            }

            const color = d3.scaleSequential()
            .domain([minVal, maxVal])
            .interpolator(d3.interpolateYlGnBu);

            // Create defs + linearGradient
            // Vertical legend on the right
            const defs = svg.append('defs');

            // vertical gradient
            const gradient = defs.append('linearGradient')
                .attr('id', 'legend-gradient')
                .attr('x1', '0%')
                .attr('x2', '0%')
                .attr('y1', '100%')
                .attr('y2', '0%');

            const stops = [0, 0.25, 0.5, 0.75, 1];
            stops.forEach(function(t) {
                gradient.append('stop')
                    .attr('offset', `${t * 100}%`)
                    .attr('stop-color', color(minVal + t * (maxVal - minVal)));
            });

            // larger, inside legend so it's visible against map
            const legendWidth = 40;
            const legendHeight = Math.min(300, height * 0.75);
            const legendX = Math.max( width - 160, width - legendWidth - 40 );
            const legendY = (height - legendHeight) / 2 - 100;

            const legendG = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${legendX}, ${legendY})`)
                .attr('pointer-events', 'none')
                .style('filter', 'url(#legend-drop)');

            // background panel to increase contrast
            legendG.append('rect')
                .attr('x', -12)
                .attr('y', -18)
                .attr('width', 120)
                .attr('height', legendHeight + 36)
                .attr('rx', 8)
                .attr('ry', 8)
                .style('fill', '#ffffff')
                .style('fill-opacity', 0.92)
                .style('stroke', 'black')
                .style('stroke-width', 1);

            // colored gradient bar
            legendG.append('rect')
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .style('fill', 'url(#legend-gradient)')
                .style('stroke', '#666')
                .style('stroke-width', 1.2)
                .style('rx', 3)
                .style('ry', 3);

            // Vertical tick labels (top = max)
            const numTicks = 5;
            const tickValues = d3.range(numTicks).map(i => Math.round(minVal + i * (maxVal - minVal) / (numTicks - 1)));

            legendG.selectAll('text.tick')
                .data(tickValues)
                .enter()
                .append('text')
                .attr('class', 'tick')
                .attr('x', legendWidth + 12)
                .attr('y', (d, i) => {
                    const frac = i / (numTicks - 1);
                    return (1 - frac) * legendHeight + 5;
                })
                .attr('text-anchor', 'start')
                .style('font-size', '13px')
                .style('font-weight', 600)
                .style('fill', '#041127')
                .text(d => d);

            // Legend title
            legendG.append('text')
                .attr('x', legendWidth - 60)
                .attr('y', -25)
                .attr('text-anchor', 'start')
                .style('font-size', '13px')
                .style('font-weight', '700')
                .style('fill', '#041127')
                .text('Nutrition Score');
        }
        
        function createScatterPlot(nutritionScores, gdpMap) {
            const data = nutritionScores
                .map(d => {
                    const gdp = gdpMap[d.ISO3];
                    const score = +d['Nutrition Score'];
                    return (gdp !== undefined && score) ? {
                        iso: d.ISO3,
                        name: d.Area,
                        gdp,
                        score
                    } : null;
                })
                .filter(Boolean);

            const xScale = d3.scaleLog()
                .domain(d3.extent(data, d => d.gdp))
                .range([0, scatterWidth])
                .nice();

            const yScale = d3.scaleLinear()
                .domain([0, 100])
                .range([scatterHeight, 0]);

            scatterGroup.append('g')
                .attr('transform', `translate(0,${scatterHeight})`)
                .call(d3.axisBottom(xScale).ticks(6, "~s"));

            scatterGroup.append('g')
                .call(d3.axisLeft(yScale));

            scatterGroup.append('text')
                .attr('x', scatterWidth / 2)
                .attr('y', scatterHeight + scatterMargin.bottom - 25)
                .attr('text-anchor', 'middle')
                .text('GDP per capita (PPP)');

            scatterGroup.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -scatterHeight / 2)
                .attr('y', -scatterMargin.left + 20)
                .attr('text-anchor', 'middle')
                .text('Nutrition Score');

            scatterDots = scatterGroup.selectAll('.dot')
                .data(data)
                .enter()
                .append('circle')
                .attr('class', 'dot')
                .attr('cx', d => xScale(d.gdp))
                .attr('cy', d => yScale(d.score))
                .attr('r', 4)
                .attr('fill', '#2c7fb8')
                .attr('opacity', 0.75)
                .on('mouseover', function(d) {
                    highlightCountry(d.iso, d.name);
                })
                .on('mouseout', () => {
                    highlightCountry(null);
                });
        }
    
        function createMapAndLegendCluster(world, clusterMap) {
            svg.selectAll("*").remove(); // clear previous map and legend

            // draw countries
            mapPaths = svg.selectAll("path")
                .data(world.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("stroke", "#333")
                .attr("stroke-width", 0.5)
                .each(function(d) {
                    const fillVal = clusterMap[d.id] ? clusterMap[d.id].color : "#ccc";
                    d.defaultFill = fillVal;
                    this._defaultFill = fillVal;
                })
                .attr("fill", function(d) { return this._defaultFill || '#ccc'; })
                .on("mouseover", function(d) {
                    const info = clusterMap[d.id];
                    const text = info ? `Cluster ${info.cluster}` : "No data";
                    infoPanel.html(`<strong>${d.properties.name}</strong><br/>${text}`);
                })
                .on("mouseout", function() {
                    infoPanel.html('Hover over a country or scatter point to see details.');
                });
        }
    
        function createLegendCluster(clusterMap) {
            svg.selectAll('.legend').remove();

            const clusters = Array.from(new Set(Object.values(clusterMap).map(d => d.cluster))).sort((a, b) => a - b);

            // legend sizing
            const legendWidth = 40;
            const legendHeight = clusters.length * 27;
            const legendX = Math.max(width - 160, width - legendWidth - 80);
            const legendY = (height - legendHeight) / 2 - 140;

            // legend group
            const legendG = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${legendX}, ${legendY})`)
                .style('filter', 'url(#legend-drop)')
                .attr('pointer-events', 'none');

            // background panel
            legendG.append('rect')
                .attr('x', -12)
                .attr('y', -18)
                .attr('width', 150)
                .attr('height', legendHeight + 36)
                .attr('rx', 8)
                .attr('ry', 8)
                .style('fill', '#ffffff')
                .style('fill-opacity', 0.92)
                .style('stroke', 'black')
                .style('stroke-width', 1);

            // draw rectangles for each cluster
            clusters.forEach((c, i) => {
                const color = Object.values(clusterMap).find(d => d.cluster == c).color;

                legendG.append('rect')
                    .attr('x', 0)
                    .attr('y', i * 30)
                    .attr('width', legendWidth)
                    .attr('height', 20)
                    .attr('rx', 3)
                    .attr('ry', 3)
                    .attr('fill', color)
                    .style('stroke', '#666')
                    .style('stroke-width', 1.2);

                legendG.append('text')
                    .attr('x', legendWidth + 10)
                    .attr('y', i * 30 + 15)
                    .text(`Cluster ${c}`)
                    .style('font-size', '13px')
                    .style('fill', '#041127')
                    .style('font-weight', 600);
            });

            // legend title
            legendG.append('text')
                .attr('x', 30)
                .attr('y', -25)
                .style('font-weight', '700')
                .style('font-size', '13px')
                .style('fill', '#041127')
                .text('Clusters');
        }

    </script>
    </div>
</body>

</html>

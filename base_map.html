<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <!-- add title -->
    <title>Food Nutrition Indices: Data Visualization</title>
    
    <!-- import required libraries here -->
    <script type="text/javascript" src="../lib/d3.v5.min.js"></script>
    <script type="text/javascript" src="../lib/d3-dsv.min.js"></script>
    <script type="text/javascript" src="../lib/topojson.v2.min.js"></script>
    <script type="text/javascript" src="../lib/d3-tip.min.js"></script>
    <script type="text/javascript" src="../lib/d3-legend.min.js"></script>
    <script type="text/javascript" src="../lib/d3-geo-projection.v2.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Page layout */
        body { 
            margin: 0; 
            padding: 28px; 
            background: linear-gradient(180deg, #f7fbff 0%, #eef6fb 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
            color: #0f1724;
        }
        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 10px 16px 40px 16px;
        }
        h2 {
            text-align: center;
            margin: 6px 0 20px;
            font-weight: 600;
            color: #0b3d91;
            letter-spacing: -0.2px;
        }

        #choropleth {
            display: block;
            margin: 0 auto 12px auto;
            background: linear-gradient(180deg, #ffffff 0%, #fbfdff 100%);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(10, 20, 40, 0.08);
            border: 1px solid rgba(13, 34, 80, 0.04);
        }

        path.country:hover {
            stroke: #06283d;
            stroke-width: 1.2px;
            opacity: 0.98;
            cursor: pointer;
        }

        .tooltip {
            font-size: 13px;
            line-height: 1.3;
            color: #041127;
            background: white;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 8px 20px rgba(12, 34, 64, 0.12);
            border: 1px solid rgba(10, 30, 60, 0.06);
            pointer-events: none;
            transition: opacity 160ms ease-out, transform 160ms ease-out;
        }

        .legend text {
            font-size: 12px;
            fill: #0b2b4a;
        }

        /* Responsive: scale down on small screens */
        @media (max-width: 700px) {
            body { padding: 14px; }
            #choropleth { width: 100% !important; height: auto !important; }
        }
        /* Responsive layout for map + scatter side-by-side */
        #viz-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: nowrap;
        }
        #map-wrapper {
            flex: 0 0 60%;
            min-width: 320px;
        }
        #scatterplot {
            flex: 0 0 38%;
            min-width: 280px;
        }
        @media (max-width: 1000px) {
            #viz-container { flex-wrap: wrap; }
            #map-wrapper, #scatterplot { flex: 0 0 100%; }
            #map-wrapper { order: 0; }
            #scatterplot { order: 1; }
        }
    </style>
</head>


<body>
    <div class="container">
        <!-- Add heading for the visualization -->
        <h2>Food Nutrition Indices: Data Visualization</h2>
        <div style="display:flex;justify-content:center;gap:8px;margin-bottom:16px;font-size:14px;">
            <label for="metric-select" style="font-weight:600;color:#0b3d91;">Metric:</label>
            <select id="metric-select" style="min-width:190px;padding:6px 10px;border-radius:6px;border:1px solid #cdd3de;">
                <option value="nutrition" selected>Nutrition Score</option>
                <option value="protein">Protein</option>
                <option value="fat">Fat</option>
                <option value="carbohydrates">Carbs</option>
            </select>
        </div>
    

    <script>
        // enter code to define margin and dimensions for svg
        const margin = {top: 50, right: 0, bottom: 50, left: 100};
        const width = 1050 - margin.left - margin.right;
        const height = 600 - margin.top - margin.bottom;
        
        const container = d3.select('body')
            .append('div')
            .attr('id', 'viz-container')
            .style('display', 'flex')
            .style('gap', '20px')
            .style('flex-wrap', 'wrap');

        const mapWrapper = container.append('div')
            .attr('id', 'map-wrapper')
            .style('display', 'flex')
            .style('flex-direction', 'column');

        const defaultInfoMessage = 'Hover over a country or scatter point to see details. Use the dropdown to switch metrics.';
        const infoPanel = mapWrapper.append('div')
            .attr('id', 'map-info')
            .style('padding', '8px 12px')
            .style('background', '#f5f5f5')
            .style('border', '1px solid #ccc')
            .style('border-radius', '4px')
            .style('min-height', '60px')
            .style('margin-bottom', '8px')
            .style('font-family', 'sans-serif')
            .style('font-size', '14px')
            .html(defaultInfoMessage);

        const svg1 = mapWrapper.append('svg')
            .attr('id', 'choropleth')
            .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
            .attr('preserveAspectRatio', 'xMidYMid meet')
            .style('width', '100%')
            .style('height', 'auto');
            

        const svg = svg1.append('g')
            .attr('id', 'countries')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        var projection = d3.geoNaturalEarth()
            .scale(200)
            .translate([width / 2 - 100, height / 1.5 - 100]);
        var path = d3.geoPath().projection(projection);

        const scatterMargin = {top: 50, right: 30, bottom: 70, left: 80};
        const scatterWidth = 600 - scatterMargin.left - scatterMargin.right;
        const scatterHeight = 600 - scatterMargin.top - scatterMargin.bottom;

        const scatterSvg = container.append('svg')
            .attr('id', 'scatterplot')
            .attr('viewBox', `0 0 ${scatterWidth + scatterMargin.left + scatterMargin.right} ${scatterHeight + scatterMargin.top + scatterMargin.bottom}`)
            .attr('preserveAspectRatio', 'xMidYMid meet')
            .style('width', '100%')
            .style('height', 'auto');

        const scatterGroup = scatterSvg.append('g')
            .attr('transform', `translate(${scatterMargin.left},${scatterMargin.top})`);
        const xScale = d3.scaleLog().range([0, scatterWidth]);
        const yScale = d3.scaleLinear().range([scatterHeight, 0]);
        const scatterXAxis = scatterGroup.append('g')
            .attr('class', 'x-axis')
            .attr('transform', `translate(0,${scatterHeight})`);
        const scatterYAxis = scatterGroup.append('g')
            .attr('class', 'y-axis');
        scatterGroup.append('text')
            .attr('x', scatterWidth / 2)
            .attr('y', scatterHeight + scatterMargin.bottom - 25)
            .attr('text-anchor', 'middle')
            .text('GDP per capita (PPP)');
        const scatterYLabel = scatterGroup.append('text')
            .attr('transform', 'rotate(-90)')
            .attr('x', -scatterHeight / 2)
            .attr('y', -scatterMargin.left + 20)
            .attr('text-anchor', 'middle')
            .text('Nutrition Score Rank');

        const gdpFormat = d3.format(',.0f');
        const metricFormatters = {
            nutrition: d3.format('.2f'),
            default: d3.format(',.0f')
        };
        let selectedMetric = 'nutrition';
        let metricStates = {};
        let currentMetricState = null;
        let mapPaths = null;
        let scatterDots = null;
        let scatterData = [];
        let countryInfo = {};
        const tooltip = d3.select('body')
            .append('div')
            .attr('class', 'tooltip')
            .style('position', 'absolute')
            .style('opacity', 0)
            .style('pointer-events', 'none');

        function updateInfoPanel(iso, fallbackName) {
            if (!iso || !currentMetricState) {
                infoPanel.html(defaultInfoMessage);
                return;
            }
            const info = countryInfo[iso] || {};
            const name = info.name || fallbackName || 'Unknown';
            const metric = currentMetricState;
            const value = metric.values[iso];
            const rank = metric.ranks[iso];
            if (selectedMetric === 'nutrition') {
                const scoreText = value != null ? metric.formatter(value) : 'N/A';
                const gdpText = info.gdp ? gdpFormat(info.gdp) : 'N/A';
                infoPanel.html(`<strong>${name}</strong><br/>Nutrition Score: ${scoreText}<br/>GDP per capita: ${gdpText}`);
            } else if (rank != null) {
                infoPanel.html(`<strong>${name}</strong><br/>${metric.label} Rank: #${rank}`);
            } else {
                infoPanel.html(`<strong>${name}</strong><br/>No data for selected metric.`);
            }
        }

        function highlightCountry(iso, fallbackName) {
            if (mapPaths) {
                mapPaths
                    .attr('stroke-width', d => d.id === iso ? 3 : 0.6)
                    .attr('stroke', d => d.id === iso ? '#ff6f00' : '#333')
                    .attr('opacity', d => !iso || d.id === iso ? 1 : 0.45);
            }
            if (scatterDots) {
                scatterDots
                    .attr('r', d => d.iso === iso ? 6 : 4)
                    .attr('fill', d => d.iso === iso ? '#d7301f' : '#2c7fb8');
            }
            updateInfoPanel(iso, fallbackName);
        }

        function showTooltip(evt, iso) {
            if (!currentMetricState) return;
            const metric = currentMetricState;
            const value = metric.values[iso];
            const rank = metric.ranks[iso];
            let content = '';
            if (selectedMetric === 'nutrition') {
                content = value != null ? `${metric.label}: ${metric.formatter(value)}` : '';
            } else if (rank != null) {
                content = `${metric.label} Rank: #${rank}`;
            }
            if (!content) {
                tooltip.style('opacity', 0);
                return;
            }
            tooltip
                .style('opacity', 0.95)
                .html(content)
                .style('left', `${evt.pageX + 12}px`)
                .style('top', `${evt.pageY - 28}px`);
        }
        function hideTooltip() {
            tooltip.style('opacity', 0);
        }

        function loadGdpData(path) {
            return d3.text(path).then(raw => {
                const lines = raw.split(/\r?\n/);
                const headerIndex = lines.findIndex(line => line.startsWith('"Country Name"'));
                if (headerIndex === -1) {
                    console.warn('GDP header row not found.');
                    return [];
                }
                const cleaned = lines.slice(headerIndex).join('\n');
                return d3.csvParse(cleaned);
            });
        }

        Promise.all([
            d3.json('./data/world_countries.json'),
            d3.csv('./data/country_nutrition_scores.csv'),
            loadGdpData('./data/API_NY.GDP.PCAP.PP.CD_DS2_en_csv_v2_254072.csv'),
            d3.csv('./data/country_nutrient_totals.csv')
        ]).then(([world, nutritionScores, gdpRows, nutrientTotals]) => {
            ready(world, nutritionScores, gdpRows, nutrientTotals);
        });
        
        // this function should be called once the data from files have been read
        // world: topojson from world_countries.json
        function ready(world, nutritionScores, gdpRows, nutrientTotals) {
            const nutrMap = buildValueMap(nutritionScores, d => +d['Nutrition Score']);
            const isoLookup = nutritionScores.reduce((acc, d) => {
                acc[d.Area] = d.ISO3;
                return acc;
            }, {});
            const isoNutrients = {};
            nutrientTotals.forEach(row => {
                const iso = isoLookup[row.Area];
                if (!iso) return;
                isoNutrients[iso] = row;
            });
            const proteinValues = buildNutrientValues(isoNutrients, 'Protein');
            const fatValues = buildNutrientValues(isoNutrients, 'Fat');
            const carbValues = buildNutrientValues(isoNutrients, 'Carbohydrates');
            registerMetric('nutrition', 'Nutrition Score', nutrMap, metricFormatters.nutrition);
            registerMetric('protein', 'Protein', proteinValues);
            registerMetric('fat', 'Fat', fatValues);
            registerMetric('carbohydrates', 'Carbohydrates', carbValues);
            const gdpMap = buildGdpMap(gdpRows);
            countryInfo = nutritionScores.reduce((acc, d) => {
                acc[d.ISO3] = { name: d.Area, score: nutrMap[d.ISO3], gdp: gdpMap[d.ISO3] };
                return acc;
            }, {});
            currentMetricState = metricStates[selectedMetric];
            initializeMap(world);
            createScatterPlot(nutritionScores, gdpMap);
            renderMetric();
            d3.select('#metric-select').on('change', function() {
                selectedMetric = this.value;
                currentMetricState = metricStates[selectedMetric];
                renderMetric();
            });
        }

        function buildValueMap(rows, accessor) {
            return rows.reduce((acc, row) => {
                const value = accessor(row);
                if (!isNaN(value)) {
                    acc[row.ISO3] = value;
                }
                return acc;
            }, {});
        }
        function buildNutrientValues(isoNutrients, column) {
            const result = {};
            Object.entries(isoNutrients).forEach(([iso, row]) => {
                const value = +row[column];
                if (!isNaN(value)) {
                    result[iso] = value;
                }
            });
            return result;
        }
        function registerMetric(id, label, values, formatter = metricFormatters.default) {
            const extentValues = Object.values(values).filter(v => v != null && !isNaN(v));
            const extent = extentValues.length ? d3.extent(extentValues) : [0, 1];
            if (extent[0] === extent[1]) {
                extent[1] = extent[0] + 1;
            }
            const { ranks, maxRank } = createRanking(values);
            metricStates[id] = { id, label, values, ranks, extent, maxRank, formatter };
        }
        function createRanking(values) {
            const entries = Object.entries(values).filter(([, v]) => v != null && !isNaN(v));
            entries.sort((a, b) => b[1] - a[1]);
            const ranks = {};
            let prevValue = null;
            let currentRank = 0;
            entries.forEach(([iso, value], idx) => {
                if (value !== prevValue) {
                    currentRank = idx + 1;
                    prevValue = value;
                }
                ranks[iso] = currentRank;
            });
            return { ranks, maxRank: entries.length };
        }
        function buildGdpMap(rows) {
            const gdpMap = {};
            rows.forEach(row => {
                const years = Object.keys(row).filter(k => /^\d{4}$/.test(k)).sort((a, b) => b - a);
                for (const year of years) {
                    const value = parseFloat(row[year]);
                    if (!isNaN(value) && value > 0) {
                        gdpMap[row['Country Code']] = value;
                        break;
                    }
                }
            });
            return gdpMap;
        }

        // this function should create a Choropleth map
        function initializeMap(world) {
            mapPaths = svg.selectAll('path')
                .data(world.features)
                .enter()
                .append('path')
                .attr('d', path)
                .attr('stroke', '#333')
                .attr('stroke-width', 0.5)
                .attr('fill', '#ccc')
                .on('mouseover', function(d) {
                    const evt = d3.event;
                    const iso = d.id;
                    highlightCountry(iso, d.properties.name);
                    showTooltip(evt, iso);
                })
                .on('mousemove', function(d) {
                    const evt = d3.event;
                    showTooltip(evt, d.id);
                })
                .on('mouseout', function() {
                    highlightCountry(null);
                    hideTooltip();
                });
        }
        function getColorScale(metricState) {
            return d3.scaleSequential()
                .domain(metricState.extent)
                .interpolator(d3.interpolateYlGnBu);
        }
        function updateMapColors(metricState) {
            if (!mapPaths) return;
            const color = getColorScale(metricState);
            mapPaths.attr('fill', d => {
                const value = metricState.values[d.id];
                return value != null && !isNaN(value) ? color(value) : '#ccc';
            });
        }
        function updateLegend(metricState) {
            svg.selectAll('.legend').remove();
            svg.selectAll('defs #legend-gradient').remove();
            const defs = svg.select('defs').empty() ? svg.append('defs') : svg.select('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', 'legend-gradient')
                .attr('x1', '0%').attr('x2', '0%').attr('y1', '0%').attr('y2', '100%');
            const color = getColorScale(metricState);
            [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                const value = metricState.extent[1] - t * (metricState.extent[1] - metricState.extent[0]);
                gradient.append('stop')
                    .attr('offset', `${t * 100}%`)
                    .attr('stop-color', color(value));
            });
            const legendHeight = Math.min(300, height * 0.75);
            const legendWidth = 40;
            const legendX = Math.max(width - 160, width - legendWidth - 40);
            const legendY = (height - legendHeight) / 2 - 100;
            const legendG = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${legendX}, ${legendY})`);
            legendG.append('rect')
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .style('fill', 'url(#legend-gradient)')
                .style('stroke', '#666')
                .style('stroke-width', 1.2)
                .style('rx', 3)
                .style('ry', 3);
            const showNumericTicks = metricState.id === 'nutrition';
            if (showNumericTicks) {
                const ticks = 5;
                const formatter = metricState.formatter || metricFormatters.default;
                d3.range(ticks).forEach(i => {
                    const frac = i / (ticks - 1);
                    const value = metricState.extent[0] + frac * (metricState.extent[1] - metricState.extent[0]);
                    legendG.append('text')
                        .attr('x', legendWidth + 12)
                        .attr('y', (1 - frac) * legendHeight + 5)
                        .style('font-size', '13px')
                        .style('font-weight', 600)
                        .text(formatter(value));
                });
            }
            legendG.append('text')
                .attr('x', legendWidth / 2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .style('font-size', '13px')
                .style('font-weight', '700')
                .text(metricState.label);
        }

        function renderMetric() {
            if (!currentMetricState) return;
            updateMapColors(currentMetricState);
            updateLegend(currentMetricState);
            updateScatterPlot(currentMetricState);
            updateInfoPanel(null);
            hideTooltip();
        }

        function createScatterPlot(nutritionScores, gdpMap) {
            scatterData = nutritionScores
                .map(d => {
                    const rawGdp = gdpMap[d.ISO3];
                    if (rawGdp == null || rawGdp < 0) return null;
                    const gdp = Math.min(200000, Math.max(1, rawGdp));
                    return { iso: d.ISO3, name: d.Area, gdp };
                })
                .filter(Boolean);
            const minGdp = d3.min(scatterData, d => d.gdp) || 1;
            xScale.domain([Math.min(minGdp, 200000), 200000]).nice();
            scatterXAxis.call(
                d3.axisBottom(xScale)
                    .ticks(6, '~s')
            );
            scatterDots = scatterGroup.selectAll('.dot')
                .data(scatterData, d => d.iso)
                .enter()
                .append('circle')
                .attr('class', 'dot')
                .attr('cx', d => xScale(d.gdp))
                .attr('cy', scatterHeight)
                .attr('r', 4)
                .attr('fill', '#2c7fb8')
                .attr('opacity', 0.75)
                .on('mouseover', function(d) {
                    highlightCountry(d.iso, d.name);
                })
                .on('mouseout', () => {
                    highlightCountry(null);
                });
        }
        function updateScatterPlot(metricState) {
            if (!metricState || !scatterDots) return;
            if (metricState.id === 'nutrition') {
                const [minVal, maxVal] = metricState.extent;
                const pad = Math.max((maxVal - minVal) * 0.05, 1);
                yScale.domain([Math.max(0, minVal - pad), maxVal + pad]);
                scatterYAxis.transition().duration(400)
                    .call(d3.axisLeft(yScale).ticks(6));
                scatterYLabel.text('Nutrition Score');
                scatterDots.transition().duration(400)
                    .attr('cy', d => {
                        const value = metricState.values[d.iso];
                        return value != null ? yScale(value) : scatterHeight + 20;
                    })
                    .attr('display', d => metricState.values[d.iso] != null ? null : 'none')
                    .attr('opacity', d => metricState.values[d.iso] != null ? 0.8 : 0.15);
            } else {
                const axisMax = (metricState.maxRank || scatterData.length || 1) + 0.5;
                yScale.domain([axisMax, 0.5]);
                scatterYAxis.transition().duration(400)
                    .call(d3.axisLeft(yScale).ticks(6).tickFormat(d3.format('d')));
                scatterYLabel.text(`${metricState.label} Rank`);
                scatterDots.transition().duration(400)
                    .attr('cy', d => {
                        const rank = metricState.ranks[d.iso];
                        return rank ? yScale(rank) : scatterHeight + 20;
                    })
                    .attr('display', d => metricState.ranks[d.iso] ? null : 'none')
                    .attr('opacity', d => metricState.ranks[d.iso] ? 0.8 : 0.15);
            }
        }
    </script>
    </div>
</body>

</html>
